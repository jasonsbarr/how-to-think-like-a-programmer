{class: part}
# Basic Programming

Your coding journey proper begins in this section! We'll start with the basic building blocks of a program: the data and logic (or functions). Every program consists of those 2 things. We'll start building up simple programs right from the beginning so you can start exercising your programmer brain right away.

# Working with Simple Data: Types, Expressions, and Statements

In this chapter you'll begin learning about data and the logic used to manipulate and process data in your programs.

What is data?

It seems like a simple question, but the answer can be surprisingly difficult to pin down.

For this book, we'll define data as information that can be divided into categories according to the operations you can make with it, and process with your program logic.

## Atomic Expressions

The simplest data is just a number, bit of text, or another value by itself.

```js
42
"hello"
true
null
```

A data value like this is a complete JavaScript expression in itself.

What's an expression?

An expression is an operation you can perform in your program that evaluates to a value.

These simple expressions that consist of a single piece of data each are *atomic*, meaning they are complete and valid in and of themselves.

They're not very useful by themselves, though. Let's look at some of the operations you can perform on them.

## Binary Expressions

We'll start with simple binary expressions. They're called "binary" because they have 2 operands.

A binary expression has the form of operand, operator, operand. In JavaScript you can do all the simple mathematical expressions you'd expect with numbers:

```js
3 + 2 //-> 5
2 * 3 //-> 6
2 ** 4 // ** is the exponent operator, so this evaluates to 16
```

You can also "add" strings of text together:

```js
"Hello" + "World" //-> "HelloWorld" - note there is no space. Spaces have to be added explicitly.
```

Mathematical operations have the precedence you would expect following the order of operations:

```js
2 + 5 * 2 //-> 12
```

You can use parentheses to force a different order of operations:

```js
(2 + 5) * 2 //-> 14
```

If you're wondering about the `//` above, that starts a *comment*. A comment is just that: a comment programmers use to convey information to other programmers. Comments are not processed by the JavaScript interpreter.

You can start single-line comments with the double slash, `//`. You can also write multiline comments that start with `/*` and end with `*/`. Programmers often use comments as a way to inform other programmers about how they should expect a bit of logic (function) to work and what kinds of data it uses.

JavaScript used to only have 1 numeric type, number, which can represent either integers or decimal numbers. Recently they've added bigints to the standard. Values of type number are limited in how large they can get on either side of 0. Bigints are integer numbers that can grow indefinitely large in either direction. Bigints are integer numbers with an `n` at the end.

```js
1000000000000000000000000000000000000000000000000000000000000000000000000000000000 //-> evaluates to Infinity
1000000000000000000000000000000000000000000000000000000000000000000000000000000000n //-> evaluates to this integer
```

You can't use numbers and bigints together in the same operation. If you try, it will cause an error.

```js
10.5 + 10n // ERROR
```

If you want to use a number value and a bigint value together, you have to convert one to the other.

```js
let x = 10.5 + Number(10n) //-> 20.5
typeof x //-> "number"
```

I've introduced a few new things in the code block above. I'll explain them later in this chapter. For now, just recognize that those expressions will evaluate to the values I've put in the comments.

## Types

I mentioned types briefly above, but now let's talk about them in more detail.

Types are categories for data that are separated according to the kinds of operations you can perform on the data. With numeric types, you do numeric operations. With the string type, you do string operations. These are called *primitive types* because they're complete values that cannot be broken down any further. "Hello" is always "Hello" no matter what you try to do to it.

Other primitive types include booleans, symbols, and `undefined`. There's another value called `null` that behaves like a primitive type in many ways.

### Numeric Types

As I mentioned above, JavaScript has 2 primitive numeric types: number and bigint.

As you've seen, you can do mathematical operations on numeric values, but you can't mix the 2 types together in the same mathematical operation.

Mathematical operations include addition, subtraction, multiplication, and division, just like you'd expect. There are also 2 additional mathematical operators: remainder and exponentiation.

`%` is the remainder operator. It evaluates to the remainder left when dividing 2 numbers, and always evaluates to an integer.

```js
10 % 3 //-> 1
```

The `**` operator handles exponentiation. It raises the 1st number to the power of the 2nd number.

```js
3 ** 4 //-> 81
```

In addition to mathematical operations, numeric values can be compared:

```js
5n > 3n //-> true
5n < 3n //-> false
5n <= 6n //-> true
17 >= 3.2 //-> true
5 === 5 //-> true, note that there are 3 equals signs
5 !== 3 //-> true
```

These operations evaluate to booleans, which we'll see here shortly.

Note that with comparison operations you actually **can** mix numbers and bigints:

```js
10n > 5 //-> true
```

That's because when you do a comparison, both the value and the type are part of the comparison.

You probably noticed earlier that I used operators with multiple equals signs, `===` and `!==`. These mean "is equal to" and "is not equal to." They measure strict equality, which means they check to see if the operands have both the same value *and* the same type.

The single equals sign has a different meaning that we'll cover shortly.

There are also comparison operators with fewer equals signs, `==` and `!=`. They only check the values, which can be coerced to different types in certain situations. I'll explain what that means later in the chapter. For now, just know that in nearly every case you're going to want to use strict equality.

### The String Type

The string type holds textual data. Some languages have separate types for individual characters and strings, but JavaScript only has the string type. A single character in JavaScript is just a string with a single character in it.

As shown earlier, you can "add" strings. More properly, you can concatenate them using the `+` operator.

```js
"Hello" + "World" //-> HelloWorld
```

You can also compare strings:

```js
"hello" === "hello" //-> true
```

You can also do greater than and less than comparisons on strings. This comparison checks one character at a time to see which character's numeric value is greater or less than the other. All characters have numeric values under the hood, but you seldom need to worry about that.

```js
"a" < "b" //-> true
"hello" > "world" //-> false
"ABC" < "XYZ" //-> true
```

There is one gotcha with comparing strings. Due to how the characters' numeric values are represented, lowercase characters are always greater than uppercase characters.

```js
"B" > "a" //-> false
```

Uppercase characters begin at 65, whereas lowercase ones start at 97, so the above comparison looks like `66 > 97` when you take their numeric values into account. That's obviously not true.

### Booleans

Booleans are an extremely simple type. There are only 2 values: `true` and `false`.

It doesn't seem like having only 2 possible values would be all that useful, but it turns out that booleans unlock whole new worlds of programming possibilities.

You surely noticed above that the comparison operations each evaluated to `true` or `false`. Those operations always evaluate to boolean values.

There are also boolean operators: `&&`, `||`, and `!`.

`!` is a unary operator, which means it only takes one operand. This unary operation evaluates to the opposite of whatever its operand is.

```js
!true //-> false
!false //-> true
!10 //-> false - I will explain this later in the chapter
```

`&&` and `||` are the "and" and "or" operators, respectively.

```js
true && true //-> true
true && false //-> false
true || false //-> true
false || false //-> false
```

These two operators do what's called short circuit evaluation. That means if the first operand satisfies a certain condition, the second operand is never evaluated. This enables some useful tricks I will demonstrate throughout the rest of the book.

Weirdly enough, you can also add booleans:

```js
true + true //-> 2
```

Don't do that, though. It's silly.

### Symbols

Symbols are a relatively new primitive type that was added to the language recently. Symbols are not equal to any other value. You create them using the `Symbol` constructor function:

```js
Symbol("hi")
```

A symbol created this way is always unique. You can create 2 symbols from the same string and they will still not be equal:

```js
Symbol("hi") === Symbol("hi") //-> false
```

You can also use the `for` method (which is a function) to create symbols that are equal to other symbols created in the same way using the same string:

```js
Symbol.for("hi") === Symbol.for("hi") //-> true
```

You probably won't use symbols too often, but they're useful because you can use them to add keys to objects that are guaranteed to be unique. Objects are a compound data type, and we'll cover them in chapter 4.

### Null and Undefined

`null` and `undefined` are similar to one another. Both represent the absence of any value, but in different ways.

`undefined` represents a value that has not been defined. It is also returned by functions that do not have a return value, as you learned in the previous chapter.

`null` is used to intentionally set a value to be empty. Confusingly, `null` in JavaScript is of type "object." The reason is because `null` is supposed to be a value used in places where there **could** be an object value. Personally, I think this was a mistake and they should have just used 1 empty type, but that's how the language was defined in the beginning so now we're stuck with it.

## Type Coercion

I briefly mentioned type coercion above. Now I'll present it with a little more detail.

Type coercion is when the JavaScript interpreter changes the type of a value to fit with the operation being performed on it.

It's easier to show examples than to explain it:

```js
5 + "5" //-> "55"
true + 1 //-> 2
"" == false //-> true
0 == false //-> true
null == undefined //-> true
0 == "" //-> true
```

This is why I said before that you should almost always prefer using the strict equality operators `===` and `!==`. The regular equality operators `==` and `!=` will coerce types to try to make the operation work.

The strict equality operators compare values **and** types, and so will work the way you probably expect it to work.

Type coercion is another one of those features that was added to the language in the beginning that many programmers wish we could get rid of. It's a common source of bugs (mistakes) in code, and they can be pretty hard to track down and fix sometimes.

JavaScript has "truthy" and "falsy" values. That means in a context where you would expect a boolean the falsy values are coerced to `false`. Truthy values are coerced to `true`.

The only falsy values are 0, "", `null`, `undefined`, and `false`. Everything else is truthy.

Sometimes having truthy and falsy values is convenient and allows you to write more succinct code. Other times it can cause unexpected problems, such as when you're checking for a numeric value and get 0, and forget to handle the case where 0 is falsy.

You can use the `typeof` unary operator to get the type of a value as a string, which can be useful:

```js
typeof "hello" //-> "string"
```

Unfortunately, sometimes `typeof` gives a result you might not expect like this:

```js
typeof null //-> "object"
```

`typeof` also does not distinguish between different object types. As far as it's concerned, a value is either a primitive (in which case it has a name) or an object (in which case it is "object"). We'll cover objects in detail in chapter 4.

## Conditional (or Ternary) Expressions

The conditional expression allows you to test a value and choose which of 2 expressions you want to evaluate based on whether the test is truthy or falsy. It is the only operator that takes 3 operands, so sometimes you'll see it called the ternary operator.

The conditional operator uses `?` and `:` between its operands.

If the first operand is truthy, the expression after `?` is evaluated. If it's falsy, the expression after `:` is evaluated. In either case, the other expression is left unevaluated.

```js
true ? "hello" : "goodbye" //-> "hello"
x > 5 ? "it is greater than five" : "it is not greater than five" //-> depends on the value of x
```

## Statements

All the logic we've seen so far has taken the form of expressions. JavaScript also has statements. Statements are bits of logic that are executed, but do not evaluate to a value. A JavaScript program is essentially a list of statements that are executed according to the order dictated by the combination of the program's data and logic.

A statement nearly always ends with a semicolon. JavaScript will often let you omit the semicolon, but the rules are tricky and it's easy to accidentally leaves one out in a way that changes the meaning of your program. When you're just getting started, you should always use semicolons where you're supposed to use them.

### Expression Statements

The simplest statement is the expression statement. An expression statement is the statement containing a "top level" expression where the statement consists entirely of a single expression. All the expressions we've used as examples so far have also been expression statements.

### Variables and Variable Declarations

Variables are names that represent certain bits of data. Sometimes you'll see people refer to a variable as a kind of "box" that holds data. I prefer to think of it as a name that points to data. However you decide to think of it, just know that a name represents some data.

A variable exists in a certain scope. The scope of a variable is the space within your program code in which the variable is valid.

Code in an inner scope has access to the variables in its containing scopes, but code in an outer scope cannot access variables in an inner scope.

JavaScript has 3 kinds of scope: global scope, function scope, and block scope. Variables in the global scope are accessible throughout the entire program. We'll cover function and block scopes when we get to block statements and functions later in this chapter.

A variable declaration has 3 parts: the declaration keyword, the variable name, and an initializer expression. Sometimes the initializer expression is optional during the declaration.

Declare variables using either the `let` or `const` keyword:

```js
let x = 10;
let y; //-> declares y, but does not initialize it
const z = "hi there";

y = false; //-> this is an expression statement containing an assignment expression

const a; //-> ERROR
```

Why does `const a;` cause an error? It's because `const` declares a variable with a **constant binding**, which means the name cannot be reassigned to another value.

Since the name cannot be reassigned you can't give it a value later, which means it has to have an initializer in the declaration.

With `let` you declare a variable binding that can be changed later in the program. This is often (though not always) a bad idea, because it's good for your program to be able to know exactly what value a variable may have. The ability to read your code and know exactly what possible values a name can refer to is called "referential transparency." There are some cases where it's necessary to change a variable's value, though.

If you do have to change a variable's value, use an assignment expression:

```js
let x;
x = 10;
```

There are also augmented assignment expressions where you perform an operation on the variable and then assign the result of that operation to the variable. Here are some examples:

```js
x += 3; // assigns the value of x + 3 to x
x -= 2;
x *= 10;
```

You can declare a variable with `let` and not initialize it, but you can't use it before it is assigned a value.

```js
let x;
x + 3; //-> ERROR
x = 10; // the program never gets here because of the error
```

You can declare multiple variables at once:

```js
let a = 1, b = 2, c = "what?";
```

Finally, for a variable binding JavaScript will not prevent you from assigning a value with a completely different type to the same variable.

```js
let greeting = "hello";
greeting = 5;
greeting; //-> 5
```

I can't think of a single time in my entire career when doing this has been a good idea.

Sometimes you'll see the keyword `var` used to declare a variable, especially in code written before 2015 when `let` and `const` were added to the language. All you need to know is that it's the old way of declaring variables and it behaves mostly like `let`. You should always use either `let` or `const` in modern JavaScript programs (preferably `const` in most situations).

Try to use descriptive variable names that indicate to someone reading the code what the value is used for. Sometimes this can be more difficult than you might think!

### Block Statements

## Function Declarations and Expressions

## Member Expressions and Methods

### The `Math` Object

## Recap

## Exercises
